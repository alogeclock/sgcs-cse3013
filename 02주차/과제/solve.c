#include "header.h"

// 직접 숫자를 작성해 보며 규칙을 확인한다.

// 0  1  2  3  4  5  6  7  8  9
// 10 11 12 13 14 15 16 17 18 19
// 20 21 22 23 24 25 26 27 28 29
// ...
// 90 91 92 93 94 95 96 97 98 99

// 0 ~ 99 → 1은 (일의 자리)에서 10회, (십의 자리)에서 10회 등장
// 0 ~ 79 → 1은 (일의 자리)에서 8회, (십의 자리)에서 10회 등장

// N = 75라면,
// (일의 자리)에서 0~5은 7 + 1회, 6~9은 7회 등장
// N / 10 = 7
// (십의 자리)에서 0~6은 10 * 1회 등장, 8~9는 0 * 1회 등장
// (십의 자리)에서 7은 6회 등장(70, 71, 72, 73, 74, 75)
// N / 10 = 0 (EOF)

// N = 583이라면,
// (일의 자리)에서 0~3이라면 59회, 4~9라면 58회 등장

// N / 10 = 58
// (십의 자리)에서 0~7이라면 10 * 6회, 9는 10*5회 등장
// (십의 자리)에서 8은 (10 * 5) + 4회 등장(580, 581, 582, 583)

// N / 10 = 5
// (백의 자리)에서 0~4라면 100 * 1회, 6~9라면 100 * 0회 등장
// (백의 자리)에서 5는 100 * 0 + 84회 등장

// (예외 처리) 0의 경우
// (일의 자리)일 땐 1개, (십의 자리)일 땐 10개,
// (백의 자리)일땐 100개씩 값을 세지 않게 된다. (앞 자리의 0은 세지 않으므로)
// 따라서, 자릿수 k가 증가할 때마다 10^k만큼 계산식에서 빼 준다.

// 위의 논리를 코드로 나타낸다.

void solve_page(int N, int* arr) {
  int range = N;  // 매 회수별 N에서 참조할 범위를 설정
  for (int base = 1; range > 0; base *= 10) {
    int last = range % 10;  // 마지막 끝 자릿수
    range /= 10;

    // 마지막 자릿수까지 계산
    for (int i = 0; i < last; i++) arr[i] += (range + 1) * base;

    // 마지막 자릿수부터 9까지 계산
    for (int i = last; i < 10; i++) arr[i] += range * base;

    // 마지막 끝 자릿수에만 특수하게 존재하는 값 추가
    arr[last] += (N % base) + 1;
    arr[0] -= base;  // 0 예외 처리
  }
}